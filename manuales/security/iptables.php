<style type="text/css">
#wrapper{



 font-style: arial;
font-size:  9.5pt;
text-align: justify
       width: 1043px;
        height:1200000px;
        background: url("/manuales/fabric_plaid.png") repeat;
        -webkit-box-shadow: 0 0 15px rgba(0,0,0,.2);
        -moz-box-shadow: 0 0 15px rgba(0,0,0,.2);
        box-shadow: 0 0 15px rgba(0,0,0,.2);
border­radius: 200px;

word-wrap: break-word;
}



</style>

<font color="red"></font>

<div id="wrapper" class="clearfix">
<pre>  <h3>
<font color="red">IPTABLES</font>

Linux uses the ipfwadm, ipchains, and iptables tools to configure firewall functions. These tools are designed for the 2.0.x, 2.2.x, and 2.4.x kernels, respectively. The 2.6.x kernels continue to use the iptables tool as well. (The 2.4.x and later kernel series include the ability to use the older tools, but only as a compile-time option.) You can configure a firewall in any of several ways:
Manually You can read up on the syntax of the tool used to configure your kernel and write
your own script. This approach is described in the upcoming section, “Using iptables.” 


With the help of a GUI configuration tool A few GUI configuration tools are available for
Linux firewall configuration, such as Firestarter (http://firestarter.sourceforge.net)
and Guarddog (http://www.simonzone.com/software/guarddog). Linux distributions
often incorporate such tools as well, although the distribution-provided tools are often very
simple. These tools let you specify certain basic information, such as the network port and the
client and server protocols you wish to allow, and they generate firewall scripts that can run
automatically when the system boots.
With the help of a website Robert Ziegler, the author of Linux Firewalls, has made a website
available that functions rather like the GUI configuration tools but via the Web. You enter
information on your system, and the website generates a firewall script. This tool is available at
http://linux-firewall-tools.com/linux/.
If you use a GUI tool or website, be sure it supports the firewall tool your kernel requires.
Most tools support iptables, and some support older tools or tools used in non-Linux OSs.
Also, you shouldn’t consider a firewall to be perfect protection. You might create a configura-
tion that actually contains flaws, or flaws might exist in the Linux kernel code that implements
the firewall rules.
 
<font color="red">Using iptables</font>

The iptables program is the utility that manages firewalls on recent Linux kernels (from 2.4.x
through at least 2.6.x). Although these kernels can also use the older ipchains tool when so
configured using kernel compile-time options, iptables is the more flexible tool and is there-
fore the preferred way of creating and managing packet-filter firewalls.

When using iptables, you should first understand how Linux’s packet filter architecture
works—you can create several types of rules, which have differing effects, so understanding
how they interact is necessary before you begin creating rules. Actually creating the rules
requires understanding the iptables command syntax and options. Finally, it’s helpful to look
at a sample firewall script and to know how it’s installed and called by the system.

<font color="red">The Linux Packet Filter Architecture</font>

In the 2.4.x and later kernels, Linux uses a series of “tables” to process all network packets it
generates or receives. Each table consists of several “chains,” which are series of pattern-match-
ing rules—when a packet matches a rule, the rule can discard the packet, forward it to another
chain, or accept the packet for local delivery. Figure 7.2 illustrates the filter table, which is
the one you normally modify when creating a firewall. Other tables include the nat table, which
implements Network Address Translation (NAT) rules, and the mangle table, which modifies
packets in specialized ways.


<img src="/images/filter_table.png" width="600" height="300" /></a>

As shown in figure  the filter table consists of three chains: INPUT, OUTPUT, and FORWARD.
These chains process traffic destined to local programs, generated by local programs,
and forwarded through a computer that’s configured as a router, respectively. You can create
rules independently for each chain. For instance, consider a rule that blocks all access directed
at port 80 (the HTTP port, used by web servers) on any IP address. Applied to the INPUT chain,
this rule blocks all access to a web server running on the local computer but doesn’t affect out-
going traffic or traffic that’s forwarded by a router. Applied to the OUTPUT chain, this rule
blocks all outgoing traffic directed at web servers, effectively rendering web browsers useless,
but it doesn’t affect incoming traffic directed at a local web server or traffic forwarded by a
router. Applied to the FORWARD chain, this rule blocks HTTP requests that might otherwise be
forwarded by a computer that functions as a router but doesn’t affect traffic from local web
browsers or to local web servers.


Much of the task of creating a firewall involves deciding which chains to modify. Generally
speaking, when you want to create a separate firewall computer (as illustrated in Figure 7.1), you
modify the FORWARD chain (to protect the computers behind the firewall) and the INPUT chain (to
protect the firewall system itself). When implementing a firewall to protect a server or workstation,
you modify the INPUT chain and perhaps the OUTPUT chain. Blocking output packets can have the
effect of preventing abuse of other systems or use of protocols you don’t want being used. For
instance, you might block outgoing traffic directed to a remote system’s port 23, effectively disal-
lowing use of Telnet clients on the system you’re configuring.


All of the chains implement a default policy. This policy determines what happens to a packet
if no rule explicitly matches it. The default for a default policy is ACCEPT, which causes packets to
be accepted. This policy is sensible in low-security situations, but for a more secure configuration,
you should change the default policy to DROP or REJECT. The former causes packets to be ignored.
To the sender, it looks as if a network link was down. The REJECT policy causes the system to
actively refuse the packet, which looks to the sender as if no server is running on the targeted port.
This option requires explicit kernel support. Both DROP and REJECT have their advantages. DROP
reduces network bandwidth use and reduces the system’s visibility on the network, whereas
REJECT can improve performance for some protocols, such as auth/ident, which may retry a con-
nection in the event a packet is lost. Using either DROP or REJECT as a default policy means that
you must explicitly open ports you want to use. This is more secure than using a default policy of
ACCEPT and explicitly closing ports because you’re less likely to accidentally leave a port open
when it should be closed. Setting a default policy is described next, in “Creating Firewall Rules.”



<font color="red">Creating Firewall Rules</font>

To create firewall rules, you use the iptables command. You should probably start with the
-L option, which lists the current configuration:

<font color="blue"># iptables -L -t filter </font>

Chain INPUT (policy ACCEPT) 
target 
prot opt source 
Chain FORWARD (policy ACCEPT) destination
target 
prot opt source 
Chain OUTPUT (policy ACCEPT) destination
target 
prot opt source 



 
